
==== ./client/src/components/ui/table.tsx ====

// src/components/ui/table.tsx
import * as React from "react";

import { cn } from "@/lib/utils";

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-x-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
));
Table.displayName = "Table";

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
));
TableHeader.displayName = "TableHeader";

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
));
TableBody.displayName = "TableBody";

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
));
TableFooter.displayName = "TableFooter";

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
));
TableRow.displayName = "TableRow";

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
));
TableHead.displayName = "TableHead";

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
));
TableCell.displayName = "TableCell";

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
));
TableCaption.displayName = "TableCaption";

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
};

==== ./client/src/components/ui/tabs.tsx ====

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }

==== ./client/src/components/ui/textarea.tsx ====

import * as React from "react"

import { cn } from "@/lib/utils"

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<"textarea">
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      ref={ref}
      {...props}
    />
  )
})
Textarea.displayName = "Textarea"

export { Textarea }

==== ./client/src/components/ui/toast.tsx ====

import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"
import { Cross2Icon } from "@radix-ui/react-icons"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-2 overflow-hidden rounded-md border p-4 pr-6 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium transition-colors hover:bg-secondary focus:outline-none focus:ring-1 focus:ring-ring disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-1 top-1 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-1 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <Cross2Icon className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold [&+div]:text-xs", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}

==== ./client/src/components/ui/toaster.tsx ====

import { useToast } from "@/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}

==== ./client/src/components/ui/toggle-group.tsx ====

"use client"

import * as React from "react"
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group"
import { type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"
import { toggleVariants } from "@/components/ui/toggle"

const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: "default",
  variant: "default",
})

const ToggleGroup = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, children, ...props }, ref) => (
  <ToggleGroupPrimitive.Root
    ref={ref}
    className={cn("flex items-center justify-center gap-1", className)}
    {...props}
  >
    <ToggleGroupContext.Provider value={{ variant, size }}>
      {children}
    </ToggleGroupContext.Provider>
  </ToggleGroupPrimitive.Root>
))

ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName

const ToggleGroupItem = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &
    VariantProps<typeof toggleVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext)

  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  )
})

ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName

export { ToggleGroup, ToggleGroupItem }

==== ./client/src/components/ui/toggle.tsx ====

import * as React from "react"
import * as TogglePrimitive from "@radix-ui/react-toggle"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const toggleVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 gap-2",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-10 px-3 min-w-10",
        sm: "h-9 px-2.5 min-w-9",
        lg: "h-11 px-5 min-w-11",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
))

Toggle.displayName = TogglePrimitive.Root.displayName

export { Toggle, toggleVariants }

==== ./client/src/components/ui/tooltip.tsx ====

"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-tooltip-content-transform-origin]",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }

==== ./client/src/context/AlunoContext.tsx ====

// Localização: client/src/context/AlunoContext.tsx
import React, { createContext, useState, useEffect, useContext, ReactNode, useCallback } from 'react';
import { jwtDecode } from 'jwt-decode';

// ***** CORREÇÃO: Adicionar 'export' aqui *****
export interface AlunoLogado { // <<< EXPORT ADICIONADO
  id: string;
  email: string;
  nome?: string;
  role: 'Aluno';
  personalId?: string;
  exp?: number;
  iat?: number;
}

interface AlunoContextType {
  aluno: AlunoLogado | null;
  tokenAluno: string | null;
  isLoadingAluno: boolean;
  loginAluno: (token: string) => void;
  logoutAluno: () => void;
  checkAlunoSession: () => void;
}

export const AlunoContext = createContext<AlunoContextType | undefined>(undefined);

export const AlunoProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [aluno, setAluno] = useState<AlunoLogado | null>(null);
  const [tokenAluno, setTokenAluno] = useState<string | null>(null);
  const [isLoadingAluno, setIsLoadingAluno] = useState<boolean>(true);

  const ALUNO_TOKEN_KEY = 'alunoAuthToken';
  const ALUNO_DATA_KEY = 'alunoData';

  const logoutAluno = useCallback(() => {
    setAluno(null);
    setTokenAluno(null);
    localStorage.removeItem(ALUNO_TOKEN_KEY);
    localStorage.removeItem(ALUNO_DATA_KEY);
    console.log("Contexto Aluno: Aluno deslogado.");
  }, []);

  const setAlunoFromToken = useCallback((token: string): AlunoLogado | null => {
    try {
      const decodedToken = jwtDecode<AlunoLogado>(token);
      if (decodedToken.exp && decodedToken.exp * 1000 < Date.now()) {
        console.warn("Contexto Aluno: Token de aluno expirado ao tentar decodificar.");
        logoutAluno();
        return null;
      }
      if (decodedToken.id && decodedToken.role === 'Aluno') {
        const alunoData: AlunoLogado = {
          id: decodedToken.id,
          email: decodedToken.email,
          nome: decodedToken.nome,
          role: decodedToken.role,
          personalId: decodedToken.personalId,
          exp: decodedToken.exp,
          iat: decodedToken.iat,
        };
        setAluno(alunoData);
        setTokenAluno(token);
        localStorage.setItem(ALUNO_TOKEN_KEY, token);
        localStorage.setItem(ALUNO_DATA_KEY, JSON.stringify(alunoData));
        console.log("Contexto Aluno: Dados do aluno definidos a partir do token:", alunoData);
        return alunoData;
      } else {
        console.error("Contexto Aluno: Payload do token de aluno inválido:", decodedToken);
        logoutAluno();
        return null;
      }
    } catch (error) {
      console.error("Contexto Aluno: Erro ao decodificar token de aluno:", error);
      logoutAluno();
      return null;
    }
  }, [logoutAluno]);

  const loginAluno = useCallback((token: string) => {
    setIsLoadingAluno(true);
    setAlunoFromToken(token);
    setIsLoadingAluno(false);
  }, [setAlunoFromToken]);

  const checkAlunoSession = useCallback(() => {
    console.log("Contexto Aluno: Verificando sessão do aluno...");
    setIsLoadingAluno(true);
    const storedToken = localStorage.getItem(ALUNO_TOKEN_KEY);
    const storedAlunoData = localStorage.getItem(ALUNO_DATA_KEY);

    if (storedToken) {
      try {
        const decoded = jwtDecode<AlunoLogado>(storedToken);
        if (decoded.exp && decoded.exp * 1000 < Date.now()) {
          console.log("Contexto Aluno: Sessão de aluno expirada no localStorage, limpando...");
          logoutAluno();
        } else if (storedAlunoData) {
          const parsedAlunoData: AlunoLogado = JSON.parse(storedAlunoData);
          if (parsedAlunoData.id && parsedAlunoData.role === 'Aluno') {
            setAluno(parsedAlunoData);
            setTokenAluno(storedToken);
            console.log("Contexto Aluno: Sessão de aluno restaurada do localStorage.");
          } else {
            console.warn("Contexto Aluno: Dados de aluno inválidos no localStorage, limpando...");
            logoutAluno();
          }
        } else {
           console.log("Contexto Aluno: Dados do aluno não encontrados no localStorage, tentando decodificar token armazenado...");
           setAlunoFromToken(storedToken);
        }
      } catch (error) {
        console.error("Contexto Aluno: Erro ao verificar sessão do aluno no localStorage, limpando:", error);
        logoutAluno();
      }
    } else {
        console.log("Contexto Aluno: Nenhum token de aluno encontrado no localStorage.");
    }
    setIsLoadingAluno(false);
  }, [logoutAluno, setAlunoFromToken]);


  useEffect(() => {
    checkAlunoSession();
  }, [checkAlunoSession]);

  useEffect(() => {
    const handleStorageChange = (event: StorageEvent) => {
      if (event.key === ALUNO_TOKEN_KEY && event.newValue === null) {
        console.log("Contexto Aluno: Token de aluno removido de outra aba/janela. Deslogando localmente...");
        setAluno(null);
        setTokenAluno(null);
      }
      if (event.key === ALUNO_DATA_KEY && event.newValue === null) {
        setAluno(null);
      }
    };
    window.addEventListener('storage', handleStorageChange);
    return () => {
      window.removeEventListener('storage', handleStorageChange);
    };
  }, []);


  return (
    <AlunoContext.Provider value={{ aluno, tokenAluno, isLoadingAluno, loginAluno, logoutAluno, checkAlunoSession }}>
      {children}
    </AlunoContext.Provider>
  );
};

export const useAluno = (): AlunoContextType => {
  const context = useContext(AlunoContext);
  if (context === undefined) {
    throw new Error('useAluno deve ser usado dentro de um AlunoProvider');
  }
  return context;
};
==== ./client/src/context/UserContext.tsx ====

// client/src/context/UserContext.tsx
import React, { createContext, useContext, useState, ReactNode, useEffect } from "react"; // Adicionado React e useEffect

// <<< ADICIONADO export >>>
// Interface para o objeto do usuário
export interface User {
  id: string; // API retorna ID do Mongo como string
  username: string; // Pode ser o email ou outro campo
  firstName: string;
  lastName: string;
  email: string;
  role: string; // 'admin' ou outro
}

// Interface para o valor do contexto
interface UserContextType {
  user: User | null;
  setUser: (user: User | null) => void;
  logout: () => void;
  isLoading: boolean; // Adicionado estado de carregamento
}

// <<< ADICIONADO export >>>
// Criação do contexto com valores padrão
export const UserContext = createContext<UserContextType>({
  user: null,
  setUser: () => { console.warn("setUser called outside UserProvider"); },
  logout: () => { console.warn("logout called outside UserProvider"); },
  isLoading: true, // Começa carregando
});

// Componente Provedor do Contexto
// (Mantém exportação)
export function UserProvider({ children }: { children: ReactNode }) {
  const [user, setUserState] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true); // Estado de loading

  // Tenta carregar do localStorage na montagem
  useEffect(() => {
    try {
      const storedUserData = localStorage.getItem('userData');
      if (storedUserData) {
        const parsedUser: User = JSON.parse(storedUserData);
         // Validação básica (ex: verificar se tem id)
         if (parsedUser && parsedUser.id) {
            setUserState(parsedUser);
         } else {
            console.warn("Dados do usuário no localStorage inválidos.");
            localStorage.removeItem('userData');
         }
      }
    } catch (error) {
      console.error("Erro ao carregar usuário do localStorage:", error);
      localStorage.removeItem('userData'); // Limpa se inválido
    } finally {
      setIsLoading(false); // Finaliza o carregamento
    }
  }, []); // Roda só uma vez

  // Função para atualizar o estado e persistir
  const handleSetUser = (newUser: User | null) => {
    setUserState(newUser);
    if (newUser) {
      localStorage.setItem('userData', JSON.stringify(newUser));
      // Token já foi salvo no login.tsx
    } else {
      // Limpa tudo no logout
      localStorage.removeItem('userData');
      localStorage.removeItem('authToken');
    }
  };


  const logout = () => {
    handleSetUser(null); // Chama a função que limpa state e localStorage
    console.log("User logged out via context.");
    // O redirecionamento geralmente é feito no componente que chama logout
  };

  // O valor fornecido pelo provider
  const value: UserContextType = {
      user,
      setUser: handleSetUser, // Usa a função que lida com localStorage
      logout,
      isLoading // Inclui isLoading no contexto
    };

  return (
    <UserContext.Provider value={value}>
      {children}
    </UserContext.Provider>
  );
}

// Hook customizado para consumir o contexto
// (Mantém exportação)
export function useUser() {
  const context = useContext(UserContext);
  if (context === undefined) {
    throw new Error("useUser must be used within a UserProvider");
  }
  return context;
}
==== ./client/src/forms/ExerciseForm.tsx ====

// client/src/forms/ExerciseForm.tsx
import React, { useEffect } from 'react'; 
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { exerciseFormSchema, ExerciseFormData, gruposMuscularesOptions, categoriasOptions } from '@/lib/validators/exerciseSchema';
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea"; 
import { Checkbox } from "@/components/ui/checkbox"; // Necessário
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"; 
import { Form, FormControl, FormDescription, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Loader2 } from 'lucide-react';

// Interface Props
interface ExerciseFormProps {
  onSubmit: (data: ExerciseFormData) => void; 
  isLoading?: boolean;                      
  initialData?: Partial<ExerciseFormData>;  
  isEditing?: boolean;                      
}

export const ExerciseForm: React.FC<ExerciseFormProps> = ({ 
  onSubmit, 
  isLoading = false, 
  initialData = {}, 
  isEditing = false 
}) => {

  const form = useForm<ExerciseFormData>({
    resolver: zodResolver(exerciseFormSchema),
    defaultValues: { 
      nome: initialData?.nome ?? '',
      grupoMuscular: initialData?.grupoMuscular ?? '', 
      descricao: initialData?.descricao ?? '',
      categoria: initialData?.categoria ?? '', 
      imageUrl: initialData?.imageUrl ?? '',
      videoUrl: initialData?.videoUrl ?? '',
      isCustom: initialData?.isCustom ?? false,
    },
  });

  // Comentado pois estava causando problemas, reavaliar se necessário para edição
  /*
  useEffect(() => {
    form.reset({
      nome: initialData?.nome ?? '',
      grupoMuscular: initialData?.grupoMuscular ?? '', 
      descricao: initialData?.descricao ?? '',
      categoria: initialData?.categoria ?? '',
      imageUrl: initialData?.imageUrl ?? '',
      videoUrl: initialData?.videoUrl ?? '',
      isCustom: initialData?.isCustom ?? false,
    });
  }, [initialData, form.reset]); 
  */

  const handleFormSubmit = (data: ExerciseFormData) => {
    console.log("Dados do formulário validados (handleFormSubmit):", data); 
    onSubmit(data); 
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(handleFormSubmit)} className="space-y-6"> 
        
        {/* Nome */}
        <FormField
          control={form.control}
          name="nome"
          render={({ field }) => ( 
            <FormItem>
              <FormLabel>Nome do Exercício *</FormLabel>
              <FormControl><Input placeholder="Ex: Supino Reto com Barra" {...field} /></FormControl>
              <FormMessage /> 
            </FormItem>
           )}
        />

        {/* Grupo Muscular */}
        <FormField
          control={form.control}
          name="grupoMuscular"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Grupo Muscular *</FormLabel>
              <Select onValueChange={field.onChange} value={field.value ?? ""}> 
                <FormControl>
                  <SelectTrigger ref={field.ref}> 
                    <SelectValue placeholder="Selecione o grupo principal" />
                  </SelectTrigger>
                </FormControl>
                <SelectContent>
                  {gruposMuscularesOptions.map((grupo) => (
                    <SelectItem key={grupo} value={grupo}>{grupo}</SelectItem>
                  ))}
                </SelectContent>
              </Select>
              <FormMessage />
            </FormItem>
          )}
        />
        
        {/* Categoria (Select) - DESCOMENTADO */}
         <FormField
          control={form.control}
          name="categoria"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Categoria</FormLabel>
              <Select onValueChange={field.onChange} value={field.value ?? ""}>
                <FormControl>
                   {/* Adicionar ref aqui também por consistência */}
                  <SelectTrigger ref={field.ref}> 
                    <SelectValue placeholder="Selecione uma categoria (opcional)" />
                  </SelectTrigger>
                </FormControl>
                <SelectContent>
                  {categoriasOptions.map((cat) => (
                    <SelectItem key={cat} value={cat}>{cat}</SelectItem>
                  ))}
                </SelectContent>
              </Select>
              <FormMessage />
            </FormItem>
          )}
        />

        {/* Descrição */}
        <FormField
          control={form.control}
          name="descricao"
          render={({ field }) => ( 
             <FormItem>
               <FormLabel>Descrição</FormLabel>
               <FormControl><Textarea placeholder="Instruções..." className="resize-y min-h-[80px]" {...field} /></FormControl>
               <FormMessage />
             </FormItem>
           )}
        />

        {/* URL Imagem - DESCOMENTADO */}
        <FormField
          control={form.control}
          name="imageUrl"
          render={({ field }) => (
            <FormItem>
              <FormLabel>URL da Imagem</FormLabel>
              <FormControl><Input type="url" placeholder="https://exemplo.com/imagem.jpg (opcional)" {...field} /></FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        {/* URL Vídeo - DESCOMENTADO */}
         <FormField
          control={form.control}
          name="videoUrl"
          render={({ field }) => (
            <FormItem>
              <FormLabel>URL do Vídeo</FormLabel>
              <FormControl><Input type="url" placeholder="https://youtube.com/watch?v=... (opcional)" {...field} /></FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

         {/* Checkbox Personalizado - DESCOMENTADO */}
         <FormField
          control={form.control}
          name="isCustom"
          render={({ field }) => (
            // Usando um layout ligeiramente diferente para Checkbox com FormField
            <FormItem className="flex flex-row items-center space-x-3 space-y-0">
              <FormControl>
                 {/* Passando props específicas do Checkbox */}
                <Checkbox
                  checked={field.value}
                  onCheckedChange={field.onChange} // RHF lida com o valor boolean
                  ref={field.ref} // Passa a ref também
                />
              </FormControl>
              <div className="space-y-1 leading-none">
                 {/* Associando o label ao checkbox corretamente */}
                 <FormLabel htmlFor={field.name} className="cursor-pointer"> 
                   Exercício Personalizado
                 </FormLabel>
                <FormDescription>Marque se este exercício foi criado por você.</FormDescription>
              </div>
               <FormMessage /> {/* Mensagem de erro se houver */}
            </FormItem>
          )}
        />

        {/* Botão Submit */}
        <Button type="submit" disabled={isLoading} className="w-full md:w-auto"> 
          {isLoading ? (<><Loader2 className="mr-2 h-4 w-4 animate-spin" />Salvando...</>) 
                     : (isEditing ? 'Salvar Alterações' : 'Criar Exercício')}
        </Button>
        
      </form>
    </Form>
  );
};
==== ./client/src/forms/student-form.tsx ====

import React, { useEffect } from 'react';
import { useLocation } from 'wouter';
import { useForm, ControllerRenderProps, FieldValues } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import * as z from 'zod';

import { Button } from '@/components/ui/button';
import {
    Form, FormControl, FormField,
    FormItem, FormLabel, FormMessage
} from '@/components/ui/form';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import {
    Select, SelectContent, SelectItem,
    SelectTrigger, SelectValue
} from '@/components/ui/select';
import { Loader2 } from 'lucide-react';
import { Separator } from '@/components/ui/separator'; // Importar Separator

// --- Funções de Validação (sem alterações) ---
const numericString = (fieldName: string) => z.string()
    .optional()
    .refine((val) => {
        if (!val || val.trim() === '') return true;
        const num = parseFloat(val.replace(',', '.'));
        return !isNaN(num) && num > 0;
    }, { message: `${fieldName} deve ser um número positivo (ex: 70 ou 70.5 ou 70,5).` });

const integerString = (fieldName: string) => z.string()
    .optional()
    .refine((val) => {
        if (!val || val.trim() === '') return true;
        const num = parseInt(val, 10);
        return !isNaN(num) && num > 0 && /^\d+$/.test(val);
    }, { message: `${fieldName} deve ser um número inteiro positivo (ex: 175).` });

const requiredNumericString = (fieldName: string) => z.string()
    .min(1, `${fieldName} é obrigatório.`)
    .refine((val) => {
        const num = parseFloat(val.replace(',', '.'));
        return !isNaN(num) && num > 0;
    }, { message: `${fieldName} deve ser um número positivo (ex: 70 ou 70.5 ou 70,5).` });

const requiredIntegerString = (fieldName: string) => z.string()
    .min(1, `${fieldName} é obrigatório.`)
    .refine((val) => {
        const num = parseInt(val, 10);
        return !isNaN(num) && num > 0 && /^\d+$/.test(val);
    }, { message: `${fieldName} deve ser um número inteiro positivo (ex: 175).` });
// --- Fim Validação ---


// Schema Zod (Com campos Peso/Altura obrigatórios)
const studentFormSchema = z.object({
    nome: z.string().min(3, "Nome completo obrigatório"),
    email: z.string().email("E-mail inválido"),
    phone: z.string().optional(),
    birthDate: z.string().refine(val => !!val, { message: "Data de nascimento obrigatória" }),
    gender: z.enum(['masculino', 'feminino', 'outro'], { errorMap: () => ({ message: "Selecione um gênero." }) }),
    goal: z.string().min(1, "Objetivo obrigatório"),
    weight: requiredNumericString("Peso"),
    height: requiredIntegerString("Altura"),
    startDate: z.string().refine(val => !!val, { message: "Data de início obrigatória" }),
    status: z.enum(['active', 'inactive'], { errorMap: () => ({ message: "Selecione um status." }) }),
    notes: z.string().optional(),
});

// Tipos (sem alterações funcionais)
export type StudentFormStringData = z.infer<typeof studentFormSchema>;
export interface StudentFormDataProcessed {
    nome: string; email: string; phone?: string; birthDate: string;
    gender: 'masculino' | 'feminino' | 'outro'; goal: string; weight: number;
    height: number; startDate: string; status: 'active' | 'inactive'; notes?: string;
}
interface Aluno {
    _id: string; nome: string; email: string; phone?: string; birthDate: string;
    gender: string; goal: string; weight?: number | null; height?: number | null;
    startDate: string; status: string; notes?: string; trainerId: number;
}
interface StudentFormProps {
    onSubmit: (data: StudentFormDataProcessed) => void;
    isLoading?: boolean; initialData?: Aluno; isEditing?: boolean;
}

// === COMPONENTE DO FORMULÁRIO COM LAYOUT REFATORADO ===
export function StudentForm({
    onSubmit: onSubmitProp, isLoading = false, initialData, isEditing = false
}: StudentFormProps) {

    const [, navigate] = useLocation();
    const form = useForm<StudentFormStringData>({
        resolver: zodResolver(studentFormSchema),
        defaultValues: { /* ... (sem alterações aqui) ... */
            nome: initialData?.nome || "",
            email: initialData?.email || "",
            phone: initialData?.phone || "",
            birthDate: initialData?.birthDate ? initialData.birthDate.split('T')[0] : "",
            gender: initialData?.gender as 'masculino' | 'feminino' | 'outro' || undefined,
            goal: initialData?.goal || "",
            weight: initialData?.weight !== null && initialData?.weight !== undefined ? String(initialData.weight) : '',
            height: initialData?.height !== null && initialData?.height !== undefined ? String(initialData.height) : '',
            startDate: initialData?.startDate ? initialData.startDate.split('T')[0] : "",
            status: initialData?.status as 'active' | 'inactive' || undefined,
            notes: initialData?.notes || "",
        },
    });

    useEffect(() => { /* ... (sem alterações aqui) ... */
        if (initialData) {
            const resetValues: Partial<StudentFormStringData> = {
                nome: initialData.nome || "", email: initialData.email || "", phone: initialData.phone || "",
                birthDate: initialData.birthDate ? initialData.birthDate.split('T')[0] : "",
                gender: initialData.gender as 'masculino' | 'feminino' | 'outro' || undefined,
                goal: initialData.goal || "",
                weight: initialData.weight !== null && initialData.weight !== undefined ? String(initialData.weight) : '',
                height: initialData.height !== null && initialData.height !== undefined ? String(initialData.height) : '',
                startDate: initialData.startDate ? initialData.startDate.split('T')[0] : "",
                status: initialData.status as 'active' | 'inactive' || undefined,
                notes: initialData.notes || "",
            };
            form.reset(resetValues);
        }
    }, [initialData, form]);

    function handleFormSubmit(data: StudentFormStringData) { /* ... (sem alterações aqui) ... */
        const processedData: StudentFormDataProcessed = {
            ...data,
            weight: parseFloat(data.weight.replace(',', '.')),
            height: parseInt(data.height, 10),
            gender: data.gender!, status: data.status!,
        };
        onSubmitProp(processedData);
    }

    return (
        <Form {...form}>
            {/* Aumentado espaçamento entre seções */}
            <form onSubmit={form.handleSubmit(handleFormSubmit)} className="space-y-8">

                {/* --- Seção Dados Pessoais --- */}
                <div className="space-y-4"> {/* Espaçamento interno da seção */}
                    <h3 className="text-lg font-semibold text-gray-800 dark:text-gray-200 border-b border-gray-200 dark:border-gray-700 pb-2">
                        Dados Pessoais
                    </h3>
                    {/* Grid responsivo para os campos */}
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-4">
                        <FormField control={form.control} name="nome" render={({ field }) => ( <FormItem><FormLabel>Nome completo*</FormLabel><FormControl><Input placeholder="Digite o nome completo" {...field} /></FormControl><FormMessage /></FormItem> )} />
                        <FormField control={form.control} name="email" render={({ field }) => ( <FormItem><FormLabel>Email*</FormLabel><FormControl><Input type="email" placeholder="exemplo@email.com" {...field} /></FormControl><FormMessage /></FormItem> )} />
                        <FormField control={form.control} name="phone" render={({ field }) => ( <FormItem><FormLabel>Telefone</FormLabel><FormControl><Input placeholder="(00) 00000-0000" {...field} value={field.value ?? ''} /></FormControl><FormMessage /></FormItem> )} />
                        <FormField control={form.control} name="birthDate" render={({ field }) => ( <FormItem><FormLabel>Data de nascimento*</FormLabel><FormControl><Input type="date" {...field} /></FormControl><FormMessage /></FormItem> )} />
                        <FormField control={form.control} name="gender" render={({ field }) => ( <FormItem><FormLabel>Gênero*</FormLabel><Select onValueChange={field.onChange} value={field.value}><FormControl><SelectTrigger><SelectValue placeholder="Selecione o gênero" /></SelectTrigger></FormControl><SelectContent><SelectItem value="masculino">Masculino</SelectItem><SelectItem value="feminino">Feminino</SelectItem><SelectItem value="outro">Outro</SelectItem></SelectContent></Select><FormMessage /></FormItem> )} />
                    </div>
                </div>

                {/* --- Seção Medidas Corporais --- */}
                <div className="space-y-4">
                     <h3 className="text-lg font-semibold text-gray-800 dark:text-gray-200 border-b border-gray-200 dark:border-gray-700 pb-2">
                        Medidas Corporais
                    </h3>
                     <div className="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-4">
                        <FormField control={form.control} name="weight" render={({ field }) => (
                            <FormItem><FormLabel>Peso (kg)*</FormLabel><FormControl><Input type="text" inputMode="decimal" placeholder="Ex: 75,5" {...field} value={field.value ?? ''} /></FormControl><FormMessage /></FormItem>
                        )} />
                        <FormField control={form.control} name="height" render={({ field }) => (
                            <FormItem><FormLabel>Altura (cm)*</FormLabel><FormControl><Input type="text" inputMode="numeric" placeholder="Ex: 178" {...field} value={field.value ?? ''} /></FormControl><FormMessage /></FormItem>
                        )} />
                    </div>
                </div>

                 {/* --- Seção Metas e Status --- */}
                <div className="space-y-4">
                     <h3 className="text-lg font-semibold text-gray-800 dark:text-gray-200 border-b border-gray-200 dark:border-gray-700 pb-2">
                        Metas e Status
                    </h3>
                    {/* Usar espaçamento simples ou grid aqui também, se preferir */}
                    <div className="space-y-4">
                        <FormField control={form.control} name="goal" render={({ field }) => ( <FormItem><FormLabel>Objetivo*</FormLabel><Select onValueChange={field.onChange} value={field.value}><FormControl><SelectTrigger><SelectValue placeholder="Selecione o objetivo" /></SelectTrigger></FormControl><SelectContent><SelectItem value="Hipertrofia">Hipertrofia</SelectItem><SelectItem value="Emagrecimento">Emagrecimento</SelectItem><SelectItem value="Reabilitação">Reabilitação</SelectItem><SelectItem value="Condicionamento físico">Condicionamento físico</SelectItem><SelectItem value="Definição muscular">Definição muscular</SelectItem><SelectItem value="Manutenção">Manutenção</SelectItem><SelectItem value="Preparação para competição">Preparação para competição</SelectItem><SelectItem value="Outros">Outros</SelectItem></SelectContent></Select><FormMessage /></FormItem> )} />
                        <FormField control={form.control} name="startDate" render={({ field }) => ( <FormItem><FormLabel>Data de início*</FormLabel><FormControl><Input type="date" {...field} /></FormControl><FormMessage /></FormItem> )} />
                        <FormField control={form.control} name="status" render={({ field }) => ( <FormItem><FormLabel>Status*</FormLabel><Select onValueChange={field.onChange} value={field.value}><FormControl><SelectTrigger><SelectValue placeholder="Selecione o status" /></SelectTrigger></FormControl><SelectContent><SelectItem value="active">Ativo</SelectItem><SelectItem value="inactive">Inativo</SelectItem></SelectContent></Select><FormMessage /></FormItem> )} />
                        <FormField control={form.control} name="notes" render={({ field }) => ( <FormItem><FormLabel>Observações</FormLabel><FormControl><Textarea placeholder="Observações adicionais..." {...field} value={field.value ?? ''} rows={4} /></FormControl><FormMessage /></FormItem> )} /> {/* Aumentei rows */}
                    </div>
                </div>

                {/* Separador antes dos botões (opcional) */}
                <Separator className="my-8" />

                {/* --- Botões de Ação --- */}
                <div className="flex justify-end space-x-3"> {/* Aumentado espaço entre botões */}
                    <Button variant="outline" type="button" onClick={() => navigate("/alunos")} disabled={isLoading}>Cancelar</Button>
                    <Button type="submit" disabled={isLoading}>
                        {isLoading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
                        {isEditing ? "Salvar Alterações" : "Adicionar Aluno"}
                    </Button>
                </div>
            </form>
        </Form>
    );
}
==== ./client/src/forms/workout-form.tsx ====

import { useState } from "react";
import { useLocation } from "wouter";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";

import { Button } from "@/components/ui/button";
import {
  Form, FormControl, FormDescription, FormField,
  FormItem, FormLabel, FormMessage
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import {
  Select, SelectContent, SelectItem,
  SelectTrigger, SelectValue
} from "@/components/ui/select";

import { apiRequest, queryClient } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";

// ✅ Schema corrigido (não depende mais do shared/schema)
const formSchema = z.object({
  name: z.string().min(1, { message: "O nome do treino é obrigatório" }),
  description: z.string().optional(),
  duration: z.coerce.number().min(1, { message: "A duração deve ser no mínimo 1 semana" }),
  status: z.string(),
  trainerId: z.number(),
});

type FormValues = z.infer<typeof formSchema>;

export function WorkoutForm() {
  const [, navigate] = useLocation();
  const { toast } = useToast();
  const [isSubmitting, setIsSubmitting] = useState(false);

  const defaultValues: Partial<FormValues> = {
    name: "",
    description: "",
    duration: 4,
    status: "active",
    trainerId: 1,
  };

  const form = useForm<FormValues>({
    resolver: zodResolver(formSchema),
    defaultValues,
  });

  async function onSubmit(data: FormValues) {
    setIsSubmitting(true);
    try {
      const result = await apiRequest("POST", "/api/workout-plans", data);
      const workoutPlan = await result.json();

      await queryClient.invalidateQueries({ queryKey: ["/api/workout-plans"] });

      toast({
        title: "Plano de treino criado com sucesso!",
        description: "Você será redirecionado para editá-lo.",
      });

      navigate(`/workouts/${workoutPlan.id}`);
    } catch (error) {
      toast({
        variant: "destructive",
        title: "Erro",
        description: "Não foi possível criar o plano de treino. Tente novamente.",
      });
      setIsSubmitting(false);
    }
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
        <FormField
          control={form.control}
          name="name"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Nome do Treino*</FormLabel>
              <FormControl>
                <Input placeholder="Ex: Treinamento de Força" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <div className="grid gap-4 sm:grid-cols-2">
          <FormField
            control={form.control}
            name="duration"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Duração (semanas)*</FormLabel>
                <FormControl>
                  <Input type="number" min={1} {...field} />
                </FormControl>
                <FormDescription>
                  Quantas semanas o plano de treino deve durar
                </FormDescription>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="status"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Status</FormLabel>
                <Select onValueChange={field.onChange} defaultValue={field.value}>
                  <FormControl>
                    <SelectTrigger>
                      <SelectValue placeholder="Selecione o status" />
                    </SelectTrigger>
                  </FormControl>
                  <SelectContent>
                    <SelectItem value="active">Ativo</SelectItem>
                    <SelectItem value="draft">Rascunho</SelectItem>
                    <SelectItem value="archived">Arquivado</SelectItem>
                  </SelectContent>
                </Select>
                <FormDescription>
                  Rascunhos não serão visíveis para os alunos até que sejam ativados
                </FormDescription>
                <FormMessage />
              </FormItem>
            )}
          />
        </div>

        <FormField
          control={form.control}
          name="description"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Descrição</FormLabel>
              <FormControl>
                <Textarea
                  placeholder="Descreva os objetivos e o foco desse plano de treino"
                  className="resize-none"
                  {...field}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <div className="flex justify-end space-x-2">
          <Button
            variant="outline"
            type="button"
            onClick={() => navigate("/workouts")}
          >
            Cancelar
          </Button>
          <Button type="submit" disabled={isSubmitting}>
            {isSubmitting ? "Criando..." : "Criar Treino"}
          </Button>
        </div>
      </form>
    </Form>
  );
}

==== ./client/src/hooks/use-mobile.tsx ====

import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}

==== ./client/src/hooks/use-students.ts ====

import { useQuery, useMutation } from "@tanstack/react-query";
import { apiRequest, queryClient } from "@/lib/queryClient";

export function useStudents(trainerId: number) {
  // Get all students for a trainer
  const getStudents = () => {
    return useQuery<any[]>({
      queryKey: ["/api/alunos", { trainerId }],
      queryFn: async () => {
        const res = await fetch(`/api/alunos?trainerId=${trainerId}`);
        if (!res.ok) throw new Error("Failed to fetch students");
        return res.json();
      }
    });
  };

  // Get a single student by ID
  const getStudent = (id: number) => {
    return useQuery<any>({
      queryKey: [`/api/alunos/${id}`],
      queryFn: async () => {
        const res = await fetch(`/api/alunos/${id}`);
        if (!res.ok) throw new Error("Failed to fetch student");
        return res.json();
      }
    });
  };

  // Add a new student
  const addStudent = () => {
    return useMutation({
      mutationFn: async (student: any) => {
        const res = await apiRequest("POST", "/api/alunos", student);
        return res.json();
      },
      onSuccess: () => {
        queryClient.invalidateQueries({ queryKey: ["/api/alunos"] });
      }
    });
  };

  // Update a student
  const updateStudent = () => {
    return useMutation({
      mutationFn: async ({ id, data }: { id: number; data: Partial<any> }) => {
        const res = await apiRequest("PUT", `/api/alunos/${id}`, data);
        return res.json();
      },
      onSuccess: (_, variables) => {
        queryClient.invalidateQueries({ queryKey: ["/api/alunos"] });
        queryClient.invalidateQueries({ queryKey: [`/api/alunos/${variables.id}`] });
      }
    });
  };

  // Delete a student
  const deleteStudent = () => {
    return useMutation({
      mutationFn: async (id: number) => {
        await apiRequest("DELETE", `/api/alunos/${id}`, undefined);
        return id;
      },
      onSuccess: () => {
        queryClient.invalidateQueries({ queryKey: ["/api/alunos"] });
      }
    });
  };

  return {
    getStudents,
    getStudent,
    addStudent,
    updateStudent,
    deleteStudent
  };
}

==== ./client/src/hooks/use-toast.ts ====

"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }

==== ./client/src/hooks/use-workouts.ts ====

import { useQuery, useMutation } from "@tanstack/react-query";
import { apiRequest, queryClient } from "@/lib/queryClient";
import type { WorkoutPlan, InsertWorkoutPlan, WorkoutExercise, InsertWorkoutExercise } from "@shared/schema";

export function useWorkouts(trainerId: number) {
  // Get all workout plans for a trainer
  const getWorkoutPlans = () => {
    return useQuery<WorkoutPlan[]>({
      queryKey: ["/api/workout-plans", { trainerId }],
      queryFn: async () => {
        const res = await fetch(`/api/workout-plans?trainerId=${trainerId}`);
        if (!res.ok) throw new Error("Failed to fetch workout plans");
        return res.json();
      }
    });
  };

  // Get a single workout plan by ID
  const getWorkoutPlan = (id: number) => {
    return useQuery<WorkoutPlan>({
      queryKey: [`/api/workout-plans/${id}`],
      queryFn: async () => {
        const res = await fetch(`/api/workout-plans/${id}`);
        if (!res.ok) throw new Error("Failed to fetch workout plan");
        return res.json();
      }
    });
  };

  // Add a new workout plan
  const addWorkoutPlan = () => {
    return useMutation({
      mutationFn: async (workoutPlan: InsertWorkoutPlan) => {
        const res = await apiRequest("POST", "/api/workout-plans", workoutPlan);
        return res.json();
      },
      onSuccess: () => {
        // Invalidate queries to refresh data
        queryClient.invalidateQueries({ queryKey: ["/api/workout-plans"] });
      }
    });
  };

  // Update a workout plan
  const updateWorkoutPlan = () => {
    return useMutation({
      mutationFn: async ({ id, data }: { id: number; data: Partial<InsertWorkoutPlan> }) => {
        const res = await apiRequest("PUT", `/api/workout-plans/${id}`, data);
        return res.json();
      },
      onSuccess: (_, variables) => {
        // Invalidate queries to refresh data
        queryClient.invalidateQueries({ queryKey: ["/api/workout-plans"] });
        queryClient.invalidateQueries({ queryKey: [`/api/workout-plans/${variables.id}`] });
      }
    });
  };

  // Delete a workout plan
  const deleteWorkoutPlan = () => {
    return useMutation({
      mutationFn: async (id: number) => {
        await apiRequest("DELETE", `/api/workout-plans/${id}`, undefined);
        return id;
      },
      onSuccess: () => {
        // Invalidate queries to refresh data
        queryClient.invalidateQueries({ queryKey: ["/api/workout-plans"] });
      }
    });
  };

  // Get exercises for a workout plan
  const getWorkoutExercises = (workoutPlanId: number) => {
    return useQuery<WorkoutExercise[]>({
      queryKey: [`/api/workout-plans/${workoutPlanId}/exercises`],
      queryFn: async () => {
        const res = await fetch(`/api/workout-plans/${workoutPlanId}/exercises`);
        if (!res.ok) throw new Error("Failed to fetch workout exercises");
        return res.json();
      }
    });
  };

  // Add an exercise to a workout plan
  const addWorkoutExercise = () => {
    return useMutation({
      mutationFn: async (workoutExercise: InsertWorkoutExercise) => {
        const res = await apiRequest("POST", "/api/workout-exercises", workoutExercise);
        return res.json();
      },
      onSuccess: (_, variables) => {
        // Invalidate queries to refresh data
        queryClient.invalidateQueries({ 
          queryKey: [`/api/workout-plans/${variables.workoutPlanId}/exercises`] 
        });
      }
    });
  };

  // Update a workout exercise
  const updateWorkoutExercise = () => {
    return useMutation({
      mutationFn: async ({ id, data, workoutPlanId }: { 
        id: number; 
        data: Partial<InsertWorkoutExercise>;
        workoutPlanId: number;
      }) => {
        const res = await apiRequest("PUT", `/api/workout-exercises/${id}`, data);
        return res.json();
      },
      onSuccess: (_, variables) => {
        // Invalidate queries to refresh data
        queryClient.invalidateQueries({ 
          queryKey: [`/api/workout-plans/${variables.workoutPlanId}/exercises`] 
        });
      }
    });
  };

  // Remove an exercise from a workout plan
  const removeWorkoutExercise = () => {
    return useMutation({
      mutationFn: async ({ id, workoutPlanId }: { id: number; workoutPlanId: number }) => {
        await apiRequest("DELETE", `/api/workout-exercises/${id}`, undefined);
        return id;
      },
      onSuccess: (_, variables) => {
        // Invalidate queries to refresh data
        queryClient.invalidateQueries({ 
          queryKey: [`/api/workout-plans/${variables.workoutPlanId}/exercises`] 
        });
      }
    });
  };

  // Assign a workout plan to a student
  const assignWorkoutToStudent = () => {
    return useMutation({
      mutationFn: async (data: { studentId: number; workoutPlanId: number }) => {
        const res = await apiRequest("POST", "/api/student-workouts", {
          studentId: data.studentId,
          workoutPlanId: data.workoutPlanId,
          assignedDate: new Date().toISOString(),
          status: "assigned",
          progress: 0
        });
        return res.json();
      },
      onSuccess: (_, variables) => {
        // Invalidate queries to refresh data
        queryClient.invalidateQueries({ 
          queryKey: [`/api/students/${variables.studentId}/workouts`] 
        });
      }
    });
  };

  return {
    getWorkoutPlans,
    getWorkoutPlan,
    addWorkoutPlan,
    updateWorkoutPlan,
    deleteWorkoutPlan,
    getWorkoutExercises,
    addWorkoutExercise,
    updateWorkoutExercise,
    removeWorkoutExercise,
    assignWorkoutToStudent
  };
}

==== ./client/src/hooks/useConfirmDialog.ts ====

// client/src/hooks/useConfirmDialog.ts
import React, { useState } from "react"; // Import React para React.ReactNode

interface ConfirmDialogOptions {
  titulo?: string;
  mensagem?: string | React.ReactNode; // <<< ALTERADO AQUI para aceitar ReactNode
  textoConfirmar?: string;
  textoCancelar?: string;
  onConfirm?: () => void;
}

export function useConfirmDialog() {
  const [isOpen, setIsOpen] = useState(false);
  const [options, setOptions] = useState<ConfirmDialogOptions>({});

  const openConfirmDialog = (options: ConfirmDialogOptions) => {
    setOptions(options);
    setIsOpen(true);
  };

  const closeConfirmDialog = () => {
    setIsOpen(false);
    // É uma boa prática resetar as options ao fechar para evitar que dados antigos persistam
    // se o modal for reaberto rapidamente com outras opções antes do setOptions ser chamado.
    // setOptions({}); // Descomente se achar necessário.
  };

  const confirm = () => {
    if (options.onConfirm) {
      options.onConfirm();
    }
    closeConfirmDialog();
  };

  return {
    isOpen,
    options,
    openConfirmDialog,
    closeConfirmDialog,
    confirm,
  };
}
